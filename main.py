from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from typing import List
from datetime import datetime
import subprocess
import uuid
import os
import time
import shutil

app = FastAPI()

# Setup folders
CLIP_DIR = "static/clips"
FINAL_DIR = "static/final"
os.makedirs(CLIP_DIR, exist_ok=True)
os.makedirs(FINAL_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

def delete_files(paths: List[str], delay=3600):
    """
    Deletes files from the given paths after a specified delay.
    This is intended to clean up temporary files generated by the application.
    """
    time.sleep(delay)
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
                print(f"Deleted {path}")
        except Exception as e:
            print(f"Error deleting {path}: {e}")

@app.post("/generate-clip")
async def generate_clip(request: Request, background_tasks: BackgroundTasks):
    """
    Generates a video clip from an image with a subtle "grow" effect,
    formatted for vertical platforms like TikTok/Reels.
    The entire image will be visible throughout the clip, starting slightly smaller
    and smoothly expanding to fill the 720x1280 frame without any cropping.
    """
    try:
        data = await request.json()
        image_url = data.get("image_url")
        duration = float(data.get("length", 5))
        frame_rate = int(data.get("frame_rate", 25))
        
        # max_zoom_param now represents how much the image "grows" from its initial state.
        # If max_zoom is 1.25, it means the image will grow to be 1.25 times its starting size.
        # The starting size is calculated to ensure the final size fills the frame.
        max_grow_factor = float(data.get("max_zoom", 1.25)) # Default grow factor to 1.25x

        # Calculate the initial scale relative to the final 720x1280 frame.
        # For a "grow" effect without cutting, the final state should be 720x1280.
        # So, the initial state is 720/max_grow_factor by 1280/max_grow_factor.
        initial_scale_width = 720 / max_grow_factor
        initial_scale_height = 1280 / max_grow_factor
        
        # Calculate the increase in size per frame
        total_frames = int(duration * frame_rate)
        width_increase_per_frame = (720 - initial_scale_width) / total_frames if total_frames > 0 else 0
        height_increase_per_frame = (1280 - initial_scale_height) / total_frames if total_frames > 0 else 0

        if not image_url:
            raise HTTPException(status_code=400, detail="Missing image_url")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        input_image = f"{CLIP_DIR}/{timestamp}.jpg"
        output_video = f"{CLIP_DIR}/{timestamp}.mp4"

        # Download image
        subprocess.run(["curl", "-L", image_url, "-o", input_image], check=True)

        # Validate if the image was downloaded successfully
        if not os.path.exists(input_image) or os.path.getsize(input_image) < 1024:
            raise HTTPException(status_code=422, detail="Invalid image or download failed")

        # FFmpeg filter complex for a "grow" effect (subtle zoom without cutting).
        # This filter chain aims to:
        # 1. Scale the input image to a high intermediate resolution for quality during transformations.
        #    This is applied first so that subsequent scaling operations have high-quality pixel data to work with.
        # 2. Apply a dynamic `scale` filter that changes the image's dimensions over time.
        #    - `w` and `h` are dynamically calculated based on `initial_scale_width/height` and `width/height_increase_per_frame`.
        #      `t` is the current timestamp (in seconds).
        #    - `force_original_aspect_ratio=increase`: This is crucial. It ensures that as the image grows,
        #      its aspect ratio is maintained, and it scales to *at least* the calculated width/height,
        #      potentially exceeding one dimension if necessary to maintain aspect ratio.
        # 3. Finally, `scale` the result to exactly 720x1280, maintaining aspect ratio and adding black bars.
        #    This *final* scale ensures the video output is always 720x1280, and because the previous step
        #    ensured the image never "cropped itself," this final step merely fits it into the frame.
        # 4. `pad` the output to ensure exact 720x1280 dimensions, with black bars if the aspect ratio
        #    didn't perfectly match after the previous scaling.
        zoom_expr = (
            # 1. Scale input to a high resolution for quality before dynamic scaling
            "scale=w=iw*min(4000/iw\\,4000/ih):h=ih*min(4000/iw\\,4000/ih),"
            # 2. Dynamic scale (the "grow" effect). Calculates target width/height based on time 't'
            f"scale=w='{initial_scale_width} + ({width_increase_per_frame}*t)':h='{initial_scale_height} + ({height_increase_per_frame}*t)':force_original_aspect_ratio=increase,"
            # 3. Final scale to fit 720x1280 maintaining aspect ratio (will not crop image content)
            "scale=720:1280:force_original_aspect_ratio=decrease,"
            # 4. Pad to fill 720x1280 frame with black bars if aspect ratio difference exists
            "pad=720:1280:(ow-iw)/2:(oh-ih)/2:black"
        )


        # FFmpeg command to create the video clip
        cmd = [
            "ffmpeg", "-y",  # -y to overwrite output files without asking
            "-loop", "1",    # Loop the input image
            "-i", input_image,
            "-vf", zoom_expr,  # Apply the combined video filter graph
            "-t", str(duration), # Set the duration of the output video
            "-r", str(frame_rate), # Set the frame rate
            "-pix_fmt", "yuv420p", # Set pixel format for broader compatibility
            output_video
        ]

        # Execute FFmpeg command
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Print FFmpeg's stderr output for debugging
        print(result.stderr.decode())

        # Check if video generation was successful
        if not os.path.exists(output_video) or os.path.getsize(output_video) == 0:
            raise HTTPException(status_code=500, detail="Video generation failed")

        # Schedule file deletion as a background task
        background_tasks.add_task(delete_files, [input_image, output_video], delay=3600)

        return {
            "clip_path": output_video,
            "public_url": f"/static/clips/{os.path.basename(output_video)}"
        }

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Subprocess error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/join-clips")
async def join_clips(request: Request, background_tasks: BackgroundTasks):
    """
    Joins multiple video clips, optionally adds an audio track and captions,
    and outputs a final video.
    """
    try:
        data = await request.json()
        clips = data.get("clips")
        audio_url = data.get("audio_url")
        captions_file = data.get("captions_file") # Path to an SRT or ASS captions file

        if not clips or not isinstance(clips, list) or len(clips) < 1:
            raise HTTPException(status_code=400, detail="Invalid or missing clips list")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        concat_txt = f"{FINAL_DIR}/concat_{timestamp}.txt"
        joined_video = f"{FINAL_DIR}/joined_{timestamp}.mp4"
        final_video = f"{FINAL_DIR}/final_{timestamp}.mp4"
        temp_audio = f"{FINAL_DIR}/audio_{timestamp}.mp3"

        # Create a concat file listing all clips for FFmpeg concatenation
        with open(concat_txt, "w") as f:
            for clip in clips:
                if not os.path.exists(clip):
                    raise HTTPException(status_code=404, detail=f"Clip not found: {clip}")
                f.write(f"file '{clip}'\n")

        # Concatenate clips using FFmpeg's concat demuxer
        subprocess.run(["ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", concat_txt, "-c", "copy", joined_video], check=True)

        # Add audio if audio_url is provided
        if audio_url:
            # Download audio file
            subprocess.run(["curl", "-L", audio_url, "-o", temp_audio], check=True)
            if not os.path.exists(temp_audio):
                raise HTTPException(status_code=500, detail="Audio download failed")

            # Merge video and audio, making the video as short as the audio
            subprocess.run([
                "ffmpeg", "-y", "-i", joined_video, "-i", temp_audio,
                "-shortest", "-c:v", "copy", "-c:a", "aac", final_video
            ], check=True)
        else:
            # If no audio, just copy the joined video to the final video path
            shutil.copy(joined_video, final_video)

        # Add captions if captions_file is provided and exists
        if captions_file and os.path.exists(captions_file):
            subtitled_video = final_video.replace(".mp4", "_subtitled.mp4")
            # Apply subtitles using the subtitles filter
            subprocess.run([
                "ffmpeg", "-y", "-i", final_video,
                "-vf", f"subtitles='{captions_file}'", # Note: using single quotes around captions_file path
                "-c:a", "copy", subtitled_video
            ], check=True)
            final_video = subtitled_video # Update final_video path to the subtitled one

        # Final check if the output video was created
        if not os.path.exists(final_video):
            raise HTTPException(status_code=500, detail="Final rendering failed")

        # Schedule deletion of temporary files and input clips
        background_tasks.add_task(delete_files, [concat_txt, joined_video, temp_audio, *clips], delay=3600)

        return {"video_url": f"/static/final/{os.path.basename(final_video)}"}

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls (FFmpeg)
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"FFmpeg error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))