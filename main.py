from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from typing import List
from datetime import datetime
import subprocess
import uuid
import os
import time
import shutil

app = FastAPI()

# Setup folders
CLIP_DIR = "static/clips"
FINAL_DIR = "static/final"
os.makedirs(CLIP_DIR, exist_ok=True)
os.makedirs(FINAL_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

def delete_files(paths: List[str], delay=3600):
    """
    Deletes files from the given paths after a specified delay.
    This is intended to clean up temporary files generated by the application.
    """
    time.sleep(delay)
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
                print(f"Deleted {path}")
        except Exception as e:
            print(f"Error deleting {path}: {e}")

@app.post("/generate-clip")
async def generate_clip(request: Request, background_tasks: BackgroundTasks):
    """
    Generates a video clip from an image with a subtle "grow" effect,
    formatted for a standard 9:16 Reels output (720x1280).
    The entire input image will be visible throughout the clip, starting slightly smaller
    and smoothly expanding to fill that 9:16 frame without any cropping of the original image content.
    """
    try:
        data = await request.json()
        image_url = data.get("image_url")
        duration = float(data.get("length", 5))
        frame_rate = int(data.get("frame_rate", 25))
        
        # --- Output video resolution for standard Reels (9:16 aspect ratio) ---
        output_width = 720
        output_height = 1280

        # max_grow_factor defines how much the image will *appear* to grow relative to its initial size.
        # If max_grow_factor is 1.25, the image starts at 1/1.25 (0.8) scale relative to its final
        # fitted size within the 720x1280 frame, and grows to 1.0 (filling that fitted size).
        max_grow_factor = float(data.get("max_zoom", 1.25)) # Default grow factor to 1.25x

        # Calculate the initial zoom level for the zoompan filter.
        # Image will start at this scale (e.g., 0.8) and grow to 1.0.
        initial_zoom_level = 1.0 / max_grow_factor
        
        # Calculate the speed at which the zoom (growth) happens per second.
        # It goes from initial_zoom_level to 1.0 over the clip's duration.
        zoom_speed_per_second = (1.0 - initial_zoom_level) / duration
        
        total_frames = int(duration * frame_rate)

        if not image_url:
            raise HTTPException(status_code=400, detail="Missing image_url")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        input_image = f"{CLIP_DIR}/{timestamp}.jpg"
        output_video = f"{CLIP_DIR}/{timestamp}.mp4"

        # Download image
        subprocess.run(["curl", "-L", image_url, "-o", input_image], check=True)

        # Validate if the image was downloaded successfully
        if not os.path.exists(input_image) or os.path.getsize(input_image) < 1024:
            raise HTTPException(status_code=422, detail="Invalid image or download failed")

        # FFmpeg filter complex for a stable "grow" effect without cutting, outputting 720x1280.
        # The order of filters is crucial for preventing cutting:
        # 1. `scale=8000:-1`: Upscales the input image to 8000px width (maintaining aspect ratio)
        #    for higher quality during the zoompan effect. This is similar to your reference command.
        # 2. `zoompan`: This filter applies the actual dynamic scaling (the "grow" effect).
        #    - `z='min({initial_zoom_level} + t*{zoom_speed_per_second}, 1.0)'`:
        #      The zoom factor starts at `initial_zoom_level` (e.g., 0.8) and increases linearly with `t` (time in seconds)
        #      up to a maximum of `1.0`. This creates the "grow" effect from a smaller size to its full fitted size.
        #    - `x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'`: These expressions keep the center of the image
        #      aligned with the center of the output frame as it grows.
        #    - `d={total_frames}`: The duration of the zoompan effect in frames.
        #    - `s={output_width}x{output_height}`: This explicitly sets the output
        #      resolution of the zoompan filter itself to 720x1280. Since your 9:16 image (576x1024) is put into this
        #      9:16 frame, it will be scaled to fit perfectly without any pillarboxing/letterboxing here.
        # 3. No further `scale` or `pad` filters are needed here, as `zoompan`'s `s` parameter directly outputs
        #    the desired size and handles the aspect ratio fitting.
        zoom_expr = (
            f"scale=8000:-1,"  # Upscale for quality before zoompan
            f"zoompan=z='min({initial_zoom_level} + t*{zoom_speed_per_second}, 1.0)':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d={total_frames}:s={output_width}x{output_height}"
        )

        # FFmpeg command to create the video clip
        cmd = [
            "ffmpeg", "-y",  # -y to overwrite output files without asking
            "-loop", "1",    # Loop the input image
            "-i", input_image,
            "-vf", zoom_expr,  # Apply the combined video filter graph
            "-t", str(duration), # Set the duration of the output video
            "-r", str(frame_rate), # Set the frame rate
            "-pix_fmt", "yuv420p", # Set pixel format for broader compatibility
            output_video
        ]

        # Execute FFmpeg command
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Print FFmpeg's stderr output for debugging
        print(result.stderr.decode())

        # Check if video generation was successful
        if not os.path.exists(output_video) or os.path.getsize(output_video) == 0:
            raise HTTPException(status_code=500, detail="Video generation failed")

        # Schedule file deletion as a background task
        background_tasks.add_task(delete_files, [input_image, output_video], delay=3600)

        return {
            "clip_path": output_video,
            "public_url": f"/static/clips/{os.path.basename(output_video)}"
        }

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Subprocess error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/join-clips")
async def join_clips(request: Request, background_tasks: BackgroundTasks):
    """
    Joins multiple video clips, optionally adds an audio track and captions,
    and outputs a final video.
    """
    try:
        data = await request.json()
        clips = data.get("clips")
        audio_url = data.get("audio_url")
        captions_file = data.get("captions_file") # Path to an SRT or ASS captions file

        if not clips or not isinstance(clips, list) or len(clips) < 1:
            raise HTTPException(status_code=400, detail="Invalid or missing clips list")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        concat_txt = f"{FINAL_DIR}/concat_{timestamp}.txt"
        joined_video = f"{FINAL_DIR}/joined_{timestamp}.mp4"
        final_video = f"{FINAL_DIR}/final_{timestamp}.mp4"
        temp_audio = f"{FINAL_DIR}/audio_{timestamp}.mp3"

        # Create a concat file listing all clips for FFmpeg concatenation
        with open(concat_txt, "w") as f:
            for clip in clips:
                if not os.path.exists(clip):
                    raise HTTPException(status_code=404, detail=f"Clip not found: {clip}")
                f.write(f"file '{clip}'\n")

        # Concatenate clips using FFmpeg's concat demuxer
        subprocess.run(["ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", concat_txt, "-c", "copy", joined_video], check=True)

        # Add audio if audio_url is provided
        if audio_url:
            # Download audio file
            subprocess.run(["curl", "-L", audio_url, "-o", temp_audio], check=True)
            if not os.path.exists(temp_audio):
                raise HTTPException(status_code=500, detail="Audio download failed")

            # Merge video and audio, making the video as short as the audio
            subprocess.run([
                "ffmpeg", "-y", "-i", joined_video, "-i", temp_audio,
                "-shortest", "-c:v", "copy", "-c:a", "aac", final_video
            ], check=True)
        else:
            # If no audio, just copy the joined video to the final video path
            shutil.copy(joined_video, final_video)

        # Add captions if captions_file is provided and exists
        if captions_file and os.path.exists(captions_file):
            subtitled_video = final_video.replace(".mp4", "_subtitled.mp4")
            # Apply subtitles using the subtitles filter
            subprocess.run([
                "ffmpeg", "-y", "-i", final_video,
                "-vf", f"subtitles='{captions_file}'", # Note: using single quotes around captions_file path
                "-c:a", "copy", subtitled_video
            ], check=True)
            final_video = subtitled_video # Update final_video path to the subtitled one

        # Final check if the output video was created
        if not os.path.exists(final_video):
            raise HTTPException(status_code=500, detail="Final rendering failed")

        # Schedule deletion of temporary files and input clips
        background_tasks.add_task(delete_files, [concat_txt, joined_video, temp_audio, *clips], delay=3600)

        return {"video_url": f"/static/final/{os.path.basename(final_video)}"}

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"FFmpeg error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))
