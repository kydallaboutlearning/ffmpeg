from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from typing import List
from datetime import datetime
import subprocess
import uuid
import os
import time
import shutil

app = FastAPI()

# Setup folders
CLIP_DIR = "static/clips"
FINAL_DIR = "static/final"
os.makedirs(CLIP_DIR, exist_ok=True)
os.makedirs(FINAL_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

def delete_files(paths: List[str], delay=3600):
    """
    Deletes files from the given paths after a specified delay.
    This is intended to clean up temporary files generated by the application.
    """
    time.sleep(delay)
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
                print(f"Deleted {path}")
        except Exception as e:
            print(f"Error deleting {path}: {e}")

@app.post("/generate-clip")
async def generate_clip(request: Request, background_tasks: BackgroundTasks):
    """
    Generates a video clip from an image with a subtle "grow" effect,
    formatted for a standard 9:16 Reels output (720x1280).
    The entire input image will be visible throughout the clip, starting slightly smaller
    and smoothly expanding to fill that 9:16 frame without any cropping of the original image content.
    """
    try:
        data = await request.json()
        image_url = data.get("image_url")
        duration = float(data.get("length", 5))
        frame_rate = int(data.get("frame_rate", 25))
        
        # --- Output video resolution for standard Reels (9:16 aspect ratio) ---
        output_width = 720
        output_height = 1280

        # max_grow_factor defines how much the image will *appear* to grow relative to its initial size.
        # If max_grow_factor is 1.25, the image starts at 1/1.25 (0.8) scale relative to its final
        # fitted size within the 720x1280 frame, and grows to 1.0 (filling that fitted size).
        max_grow_factor = float(data.get("max_zoom", 1.25)) # Default grow factor to 1.25x

        # Calculate the initial zoom level. Image will start at this scale (e.g., 0.8).
        initial_zoom_level = 1.0 / max_grow_factor
        
        # Calculate the rate of change per second to reach zoom_end_level (1.0)
        # from initial_zoom_level over the given duration.
        zoom_rate_per_second = (1.0 - initial_zoom_level) / duration
        
        # Total frames for the zoompan duration parameter. This dictates how long the zoom lasts.
        total_frames_for_zoom = int(duration * frame_rate)

        if not image_url:
            raise HTTPException(status_code=400, detail="Missing image_url")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        input_image = f"{CLIP_DIR}/{timestamp}.jpg"
        output_video = f"{CLIP_DIR}/{timestamp}.mp4"

        # Download image
        subprocess.run(["curl", "-L", image_url, "-o", input_image], check=True)

        # Validate if the image was downloaded successfully
        if not os.path.exists(input_image) or os.path.getsize(input_image) < 1024:
            raise HTTPException(status_code=422, detail="Invalid image or download failed")

        # FFmpeg filter complex for a stable "grow" effect without cutting, outputting 720x1280.
        # 1. `zoompan`: This filter applies the actual dynamic scaling (the "grow" effect).
        #    - `z='({initial_zoom_level:.6f} + t*{zoom_rate_per_second:.6f})'`:
        #      The zoom factor starts at `initial_zoom_level` and increases linearly with `t` (time in seconds).
        #      The `:.6f` formatting is crucial for FFmpeg's parser.
        #    - `x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'`: Keep the center of the image aligned.
        #    - `d={total_frames_for_zoom}`: The duration of the zoompan effect in frames.
        #    - `s={output_width}x{output_height}`: Explicitly sets the output resolution of this filter.
        #      Since the source is 9:16 and target is 9:16, it will scale perfectly.
        zoom_expr = (
            f"zoompan=z='({initial_zoom_level:.6f} + t*{zoom_rate_per_second:.6f})':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d={total_frames_for_zoom}:s={output_width}x{output_height}"
        )

        # FFmpeg command to create the video clip
        cmd = [
            "ffmpeg", "-y",  # -y to overwrite output files without asking
            "-loop", "1",    # Loop the input image
            "-i", input_image,
            "-vf", zoom_expr,  # Apply the combined video filter graph
            "-t", str(duration), # Set the total duration of the output video
            "-r", str(frame_rate), # Set the frame rate
            "-pix_fmt", "yuv420p", # Set pixel format for broader compatibility
            output_video
        ]

        # Execute FFmpeg command
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Print FFmpeg's stderr output for debugging
        print(result.stderr.decode())

        # Check if video generation was successful
        if not os.path.exists(output_video) or os.path.getsize(output_video) == 0:
            raise HTTPException(status_code=500, detail="Video generation failed")

        # Schedule file deletion as a background task
        background_tasks.add_task(delete_files, [input_image, output_video], delay=3600)

        return {
            "clip_path": output_video,
            "public_url": f"/static/clips/{os.path.basename(output_video)}"
        }

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Subprocess error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/join-clips")
async def join_clips(request: Request, background_tasks: BackgroundTasks):
    """
    Joins multiple video clips, optionally adds an audio track and captions,
    and outputs a final video.
    """
    try:
        data = await request.json()
        clips = data.get("clips")
        audio_url = data.get("audio_url")
        captions_file = data.get("captions_file") # Path to an SRT or ASS captions file

        if not clips or not isinstance(clips, list) or len(clips) < 1:
            raise HTTPException(status_code=400, detail="Invalid or missing clips list")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        concat_txt = f"{FINAL_DIR}/concat_{timestamp}.txt"
        joined_video = f"{FINAL_DIR}/joined_{timestamp}.mp4"
        final_video = f"{FINAL_DIR}/final_{timestamp}.mp4"
        temp_audio = f"{FINAL_DIR}/audio_{timestamp}.mp3"

        # Create a concat file listing all clips for FFmpeg concatenation
        with open(concat_txt, "w") as f:
            for clip in clips:
                if not os.path.exists(clip):
                    raise HTTPException(status_code=404, detail=f"Clip not found: {clip}")
                f.write(f"file '{clip}'\n")

        # Concatenate clips using FFmpeg's concat demuxer
        subprocess.run(["ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", concat_txt, "-c", "copy", joined_video], check=True)

        # Add audio if audio_url is provided
        if audio_url:
            # Download audio file
            subprocess.run(["curl", "-L", audio_url, "-o", temp_audio], check=True)
            if not os.path.exists(temp_audio):
                raise HTTPException(status_code=500, detail="Audio download failed")

            # Merge video and audio, making the video as short as the audio
            subprocess.run([
                "ffmpeg", "-y", "-i", joined_video, "-i", temp_audio,
                "-shortest", "-c:v", "copy", "-c:a", "aac", final_video
            ], check=True)
        else:
            # If no audio, just copy the joined video to the final video path
            shutil.copy(joined_video, final_video)

        # Add captions if captions_file is provided and exists
        if captions_file and os.path.exists(captions_file):
            subtitled_video = final_video.replace(".mp4", "_subtitled.mp4")
            # Apply subtitles using the subtitles filter
            subprocess.run([
                "ffmpeg", "-y", "-i", final_video,
                "-vf", f"subtitles='{captions_file}'", # Note: using single quotes around captions_file path
                "-c:a", "copy", subtitled_video
            ], check=True)
            final_video = subtitled_video # Update final_video path to the subtitled one

        # Final check if the output video was created
        if not os.path.exists(final_video):
            raise HTTPException(status_code=500, detail="Final rendering failed")

        # Schedule deletion of temporary files and input clips
        background_tasks.add_task(delete_files, [concat_txt, joined_video, temp_audio, *clips], delay=3600)

        return {"video_url": f"/static/final/{os.path.basename(final_video)}"}

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"FFmpeg error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))
