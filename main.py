from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from typing import List
from datetime import datetime
import subprocess
import uuid
import os
import time
import shutil

app = FastAPI()

# Setup folders
CLIP_DIR = "static/clips"
FINAL_DIR = "static/final"
os.makedirs(CLIP_DIR, exist_ok=True)
os.makedirs(FINAL_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

def delete_files(paths: List[str], delay=3600):
    """
    Deletes files from the given paths after a specified delay.
    This is intended to clean up temporary files generated by the application.
    """
    time.sleep(delay)
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
                print(f"Deleted {path}")
        except Exception as e:
            print(f"Error deleting {path}: {e}")

@app.post("/generate-clip")
async def generate_clip(request: Request, background_tasks: BackgroundTasks):
    """
    Generates a video clip from an image with a subtle zoom effect,
    formatted for vertical platforms like TikTok/Reels.
    The entire image will be visible in the initial frame, with black bars added if its aspect ratio doesn't match.
    The zoom effect will then apply to this framed image.
    """
    try:
        data = await request.json()
        image_url = data.get("image_url")
        duration = float(data.get("length", 5))
        frame_rate = int(data.get("frame_rate", 25))
        
        # Zoom parameters for subtle effect
        # Default zoom speed for a smooth, slow zoom
        zoom_speed_param = float(data.get("zoom_speed", 0.0002)) # Even slower zoom
        # Default max zoom to 1.2x, adjustable via 'max_zoom' in request body
        max_zoom_param = float(data.get("max_zoom", 1.2)) # Set default max zoom to 1.2x

        if not image_url:
            raise HTTPException(status_code=400, detail="Missing image_url")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        input_image = f"{CLIP_DIR}/{timestamp}.jpg"
        output_video = f"{CLIP_DIR}/{timestamp}.mp4"

        # Download image
        subprocess.run(["curl", "-L", image_url, "-o", input_image], check=True)

        # Validate if the image was downloaded successfully
        if not os.path.exists(input_image) or os.path.getsize(input_image) < 1024:
            raise HTTPException(status_code=422, detail="Invalid image or download failed")

        # FFmpeg filter complex for zoom, scaling, and padding for Reels format.
        # The order of filters is crucial here:
        # 1. Scale input image to a high intermediate resolution for better quality during zoom.
        #    `iw*min(8000/iw,8000/ih):ih*min(8000/iw,8000/ih)` ensures it scales up to a max of 8000px on
        #    either width or height, maintaining aspect ratio.
        # 2. Scale the high-res image to fit exactly 720x1280 (Reels format),
        #    maintaining aspect ratio and adding black bars if needed. This ensures the
        #    *entire* image is visible and correctly framed *before* the zoom begins.
        # 3. Apply the `zoompan` effect to this *already framed* image. The zoom will now
        #    start from a state where the full image is shown and magnify from there.
        #    `z='min(zoom+{zoom_speed_param},{max_zoom_param})'` controls the zoom level.
        #    `d={int(duration * frame_rate)}` sets the duration of the zoom.
        zoom_expr = (
            f"scale=iw*min(8000/iw,8000/ih):ih*min(8000/iw,8000/ih),"  # Upscale for quality
            f"scale=720:1280:force_original_aspect_ratio=decrease,"    # Fit to Reels frame, no cropping
            f"pad=720:1280:(ow-iw)/2:(oh-ih)/2:black,"                  # Pad with black bars to fill Reels frame
            f"zoompan=z='min(zoom+{zoom_speed_param},{max_zoom_param})':d={int(duration * frame_rate)}" # Apply zoom to the framed image
        )

        # FFmpeg command to create the video clip
        cmd = [
            "ffmpeg", "-y",  # -y to overwrite output files without asking
            "-loop", "1",    # Loop the input image
            "-i", input_image,
            "-vf", zoom_expr,  # Apply the combined video filter graph
            "-t", str(duration), # Set the duration of the output video
            "-r", str(frame_rate), # Set the frame rate
            "-pix_fmt", "yuv420p", # Set pixel format for broader compatibility
            output_video
        ]

        # Execute FFmpeg command
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Print FFmpeg's stderr output for debugging
        print(result.stderr.decode())

        # Check if video generation was successful
        if not os.path.exists(output_video) or os.path.getsize(output_video) == 0:
            raise HTTPException(status_code=500, detail="Video generation failed")

        # Schedule file deletion as a background task
        background_tasks.add_task(delete_files, [input_image, output_video], delay=3600)

        return {
            "clip_path": output_video,
            "public_url": f"/static/clips/{os.path.basename(output_video)}"
        }

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Subprocess error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/join-clips")
async def join_clips(request: Request, background_tasks: BackgroundTasks):
    """
    Joins multiple video clips, optionally adds an audio track and captions,
    and outputs a final video.
    """
    try:
        data = await request.json()
        clips = data.get("clips")
        audio_url = data.get("audio_url")
        captions_file = data.get("captions_file") # Path to an SRT or ASS captions file

        if not clips or not isinstance(clips, list) or len(clips) < 1:
            raise HTTPException(status_code=400, detail="Invalid or missing clips list")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        concat_txt = f"{FINAL_DIR}/concat_{timestamp}.txt"
        joined_video = f"{FINAL_DIR}/joined_{timestamp}.mp4"
        final_video = f"{FINAL_DIR}/final_{timestamp}.mp4"
        temp_audio = f"{FINAL_DIR}/audio_{timestamp}.mp3"

        # Create a concat file listing all clips for FFmpeg concatenation
        with open(concat_txt, "w") as f:
            for clip in clips:
                if not os.path.exists(clip):
                    raise HTTPException(status_code=404, detail=f"Clip not found: {clip}")
                f.write(f"file '{clip}'\n")

        # Concatenate clips using FFmpeg's concat demuxer
        subprocess.run(["ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", concat_txt, "-c", "copy", joined_video], check=True)

        # Add audio if audio_url is provided
        if audio_url:
            # Download audio file
            subprocess.run(["curl", "-L", audio_url, "-o", temp_audio], check=True)
            if not os.path.exists(temp_audio):
                raise HTTPException(status_code=500, detail="Audio download failed")

            # Merge video and audio, making the video as short as the audio
            subprocess.run([
                "ffmpeg", "-y", "-i", joined_video, "-i", temp_audio,
                "-shortest", "-c:v", "copy", "-c:a", "aac", final_video
            ], check=True)
        else:
            # If no audio, just copy the joined video to the final video path
            shutil.copy(joined_video, final_video)

        # Add captions if captions_file is provided and exists
        if captions_file and os.path.exists(captions_file):
            subtitled_video = final_video.replace(".mp4", "_subtitled.mp4")
            # Apply subtitles using the subtitles filter
            subprocess.run([
                "ffmpeg", "-y", "-i", final_video,
                "-vf", f"subtitles='{captions_file}'", # Note: using single quotes around captions_file path
                "-c:a", "copy", subtitled_video
            ], check=True)
            final_video = subtitled_video # Update final_video path to the subtitled one

        # Final check if the output video was created
        if not os.path.exists(final_video):
            raise HTTPException(status_code=500, detail="Final rendering failed")

        # Schedule deletion of temporary files and input clips
        background_tasks.add_task(delete_files, [concat_txt, joined_video, temp_audio, *clips], delay=3600)

        return {"video_url": f"/static/final/{os.path.basename(final_video)}"}

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls (FFmpeg)
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"FFmpeg error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))
