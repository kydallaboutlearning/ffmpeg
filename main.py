from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from typing import List
from datetime import datetime
import subprocess
import uuid
import os
import time
import shutil

app = FastAPI()

# Setup folders
CLIP_DIR = "static/clips"
FINAL_DIR = "static/final"
os.makedirs(CLIP_DIR, exist_ok=True)
os.makedirs(FINAL_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

def delete_files(paths: List[str], delay=3600):
    """
    Deletes files from the given paths after a specified delay.
    This is intended to clean up temporary files generated by the application.
    """
    time.sleep(delay)
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
                print(f"Deleted {path}")
        except Exception as e:
            print(f"Error deleting {path}: {e}")

@app.post("/generate-clip")
async def generate_clip(request: Request, background_tasks: BackgroundTasks):
    """
    Generates a video clip from an image with a subtle zoom effect,
    formatted for vertical platforms like TikTok/Reels.
    """
    try:
        data = await request.json()
        image_url = data.get("image_url")
        duration = float(data.get("length", 5))
        frame_rate = int(data.get("frame_rate", 25))
        zoom_speed = float(data.get("zoom_speed", 0.001))  # very subtle zoom

        if not image_url:
            raise HTTPException(status_code=400, detail="Missing image_url")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        input_image = f"{CLIP_DIR}/{timestamp}.jpg"
        output_video = f"{CLIP_DIR}/{timestamp}.mp4"

        # Download image
        # Using subprocess.run for external commands like curl.
        # check=True raises CalledProcessError if the command returns a non-zero exit code.
        subprocess.run(["curl", "-L", image_url, "-o", input_image], check=True)

        # Validate if the image was downloaded successfully
        if not os.path.exists(input_image) or os.path.getsize(input_image) < 1024:
            raise HTTPException(status_code=422, detail="Invalid image or download failed")

        # FFmpeg filter complex for zoom, scaling, and padding.
        # Using triple quotes for zoom_expr to allow single quotes within the string without escaping.
        zoom_expr = (
            f"scale=8000:-1,"  # Upscale for clarity before zoompan
            f"zoompan=z='min(zoom+{zoom_speed},1.5)':x='if(gte(zoom,1.5),x,x+1)':y='y':d={int(duration * frame_rate)},"  # Smooth zoom over clip duration
            f"scale=720:1280:force_original_aspect_ratio=decrease,"  # Scale to fit 720x1280 without cropping
            f"pad=720:1280:(ow-iw)/2:(oh-ih)/2:black"  # Pad to fill 720x1280 with black bars if aspect ratio doesn't match
        )

        # FFmpeg command to create the video clip
        cmd = [
            "ffmpeg", "-y",  # -y to overwrite output files without asking
            "-loop", "1",    # Loop the input image
            "-i", input_image,
            "-vf", zoom_expr,  # Apply the video filter graph
            "-t", str(duration), # Set the duration of the output video
            "-r", str(frame_rate), # Set the frame rate
            "-pix_fmt", "yuv420p", # Set pixel format for broader compatibility
            output_video
        ]

        # Execute FFmpeg command
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # Print FFmpeg's stderr output for debugging
        print(result.stderr.decode())

        # Check if video generation was successful
        if not os.path.exists(output_video) or os.path.getsize(output_video) == 0:
            raise HTTPException(status_code=500, detail="Video generation failed")

        # Schedule file deletion as a background task
        background_tasks.add_task(delete_files, [input_image, output_video], delay=3600)

        return {
            "clip_path": output_video,
            "public_url": f"/static/clips/{os.path.basename(output_video)}"
        }

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Subprocess error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/join-clips")
async def join_clips(request: Request, background_tasks: BackgroundTasks):
    """
    Joins multiple video clips, optionally adds an audio track and captions,
    and outputs a final video.
    """
    try:
        data = await request.json()
        clips = data.get("clips")
        audio_url = data.get("audio_url")
        captions_file = data.get("captions_file") # Path to an SRT or ASS captions file

        if not clips or not isinstance(clips, list) or len(clips) < 1:
            raise HTTPException(status_code=400, detail="Invalid or missing clips list")

        timestamp = datetime.now().isoformat().replace(":", "-").replace(".", "-")
        concat_txt = f"{FINAL_DIR}/concat_{timestamp}.txt"
        joined_video = f"{FINAL_DIR}/joined_{timestamp}.mp4"
        final_video = f"{FINAL_DIR}/final_{timestamp}.mp4"
        temp_audio = f"{FINAL_DIR}/audio_{timestamp}.mp3"

        # Create a concat file listing all clips for FFmpeg concatenation
        with open(concat_txt, "w") as f:
            for clip in clips:
                if not os.path.exists(clip):
                    raise HTTPException(status_code=404, detail=f"Clip not found: {clip}")
                f.write(f"file '{clip}'\n")

        # Concatenate clips using FFmpeg's concat demuxer
        subprocess.run(["ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", concat_txt, "-c", "copy", joined_video], check=True)

        # Add audio if audio_url is provided
        if audio_url:
            # Download audio file
            subprocess.run(["curl", "-L", audio_url, "-o", temp_audio], check=True)
            if not os.path.exists(temp_audio):
                raise HTTPException(status_code=500, detail="Audio download failed")

            # Merge video and audio, making the video as short as the audio
            subprocess.run([
                "ffmpeg", "-y", "-i", joined_video, "-i", temp_audio,
                "-shortest", "-c:v", "copy", "-c:a", "aac", final_video
            ], check=True)
        else:
            # If no audio, just copy the joined video to the final video path
            shutil.copy(joined_video, final_video)

        # Add captions if captions_file is provided and exists
        if captions_file and os.path.exists(captions_file):
            subtitled_video = final_video.replace(".mp4", "_subtitled.mp4")
            # Apply subtitles using the subtitles filter
            subprocess.run([
                "ffmpeg", "-y", "-i", final_video,
                "-vf", f"subtitles='{captions_file}'", # Note: using single quotes around captions_file path
                "-c:a", "copy", subtitled_video
            ], check=True)
            final_video = subtitled_video # Update final_video path to the subtitled one

        # Final check if the output video was created
        if not os.path.exists(final_video):
            raise HTTPException(status_code=500, detail="Final rendering failed")

        # Schedule deletion of temporary files and input clips
        background_tasks.add_task(delete_files, [concat_txt, joined_video, temp_audio, *clips], delay=3600)

        return {"video_url": f"/static/final/{os.path.basename(final_video)}"}

    except subprocess.CalledProcessError as err:
        # Catch errors specifically from subprocess calls (FFmpeg)
        print(f"FFmpeg error details: {err.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"FFmpeg error: {err}. FFmpeg output: {err.stderr.decode()}")
    except Exception as e:
        # Catch any other unexpected errors
        raise HTTPException(status_code=500, detail=str(e))
